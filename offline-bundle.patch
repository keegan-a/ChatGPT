From d08260105c834fb59d2d750084fdc666fac166c1 Mon Sep 17 00:00:00 2001
From: Codex <codex@openai.com>
Date: Sun, 19 Oct 2025 23:38:14 +0000
Subject: [PATCH] Add offline fallback and precache build in service worker

## Summary
- add a service worker template that precaches build assets, cleans old caches, and serves an offline fallback
- create an offline HTML screen with responsive styling for use when the network is unavailable
- enhance scripts/prepare-web.js to copy the offline assets, inject the precache manifest/version, and ensure service worker registration during deployment

## Testing
- node scripts/prepare-web.js
---
 offline.html           | 148 ++++++++++++++++++++++++++++
 scripts/prepare-web.js | 217 +++++++++++++++++++++++++++++++++++++++++
 sw.js                  | 126 ++++++++++++++++++++++++
 3 files changed, 491 insertions(+)
 create mode 100644 offline.html
 create mode 100755 scripts/prepare-web.js
 create mode 100644 sw.js

diff --git a/offline.html b/offline.html
new file mode 100644
index 0000000..00f4737
--- /dev/null
+++ b/offline.html
@@ -0,0 +1,148 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1" />
+    <title>ChatGPT &mdash; Offline</title>
+    <style>
+      :root {
+        color-scheme: light dark;
+        --bg-color: #0e1117;
+        --card-bg: rgba(255, 255, 255, 0.06);
+        --text-color: #f4f6fb;
+        --accent: #10a37f;
+        --muted: rgba(244, 246, 251, 0.75);
+      }
+      @media (prefers-color-scheme: light) {
+        :root {
+          --bg-color: #f7f9fc;
+          --card-bg: rgba(14, 17, 23, 0.08);
+          --text-color: #111320;
+          --accent: #0b8365;
+          --muted: rgba(17, 19, 32, 0.72);
+        }
+      }
+      * {
+        box-sizing: border-box;
+      }
+      body {
+        margin: 0;
+        min-height: 100vh;
+        font-family: "Inter", "Segoe UI", sans-serif;
+        background: radial-gradient(circle at 20% 20%, rgba(16, 163, 127, 0.2), transparent 55%),
+          radial-gradient(circle at 80% 0%, rgba(80, 55, 218, 0.25), transparent 60%), var(--bg-color);
+        color: var(--text-color);
+        display: grid;
+        place-items: center;
+        padding: 1.5rem;
+      }
+      main {
+        width: min(480px, 100%);
+        background: var(--card-bg);
+        border-radius: 20px;
+        padding: clamp(1.75rem, 3vw, 2.5rem);
+        backdrop-filter: blur(24px);
+        box-shadow: 0 24px 60px rgba(15, 17, 26, 0.35);
+      }
+      h1 {
+        margin: 0 0 1rem;
+        font-size: clamp(1.75rem, 4vw, 2.4rem);
+        letter-spacing: -0.02em;
+      }
+      p {
+        margin: 0 0 1.25rem;
+        line-height: 1.6;
+        color: var(--muted);
+      }
+      .actions {
+        display: flex;
+        flex-wrap: wrap;
+        gap: 0.75rem;
+        margin-top: 1.5rem;
+      }
+      .actions button,
+      .actions a {
+        appearance: none;
+        border-radius: 999px;
+        border: 0;
+        padding: 0.75rem 1.5rem;
+        font-size: 0.95rem;
+        cursor: pointer;
+        transition: transform 150ms ease, box-shadow 150ms ease;
+        text-decoration: none;
+      }
+      .actions .retry {
+        background: var(--accent);
+        color: white;
+        box-shadow: 0 12px 24px rgba(16, 163, 127, 0.35);
+      }
+      .actions .retry:hover,
+      .actions .retry:focus-visible {
+        transform: translateY(-1px);
+        box-shadow: 0 14px 28px rgba(16, 163, 127, 0.42);
+      }
+      .actions .cached {
+        background: transparent;
+        color: inherit;
+        border: 1px solid rgba(244, 246, 251, 0.35);
+      }
+      footer {
+        margin-top: 2.5rem;
+        font-size: 0.85rem;
+        color: var(--muted);
+        opacity: 0.9;
+      }
+      svg {
+        display: block;
+        width: clamp(64px, 18vw, 96px);
+        margin-bottom: 1.5rem;
+      }
+      @media (max-width: 480px) {
+        main {
+          padding: 1.5rem;
+        }
+        .actions {
+          flex-direction: column;
+        }
+        .actions .cached,
+        .actions .retry {
+          width: 100%;
+          text-align: center;
+        }
+      }
+    </style>
+  </head>
+  <body>
+    <main>
+      <svg viewBox="0 0 120 120" role="img" aria-labelledby="offline-title">
+        <title id="offline-title">Disconnected cloud illustration</title>
+        <defs>
+          <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
+            <stop offset="0%" stop-color="#10a37f" stop-opacity="0.85" />
+            <stop offset="100%" stop-color="#5037da" stop-opacity="0.75" />
+          </linearGradient>
+        </defs>
+        <path
+          d="M39.5 45c2.2-14.7 14.7-26 30-26 13 0 24.2 8.3 28.4 20 13.2 1.7 23.1 12.9 23.1 26.4 0 14.7-11.9 26.6-26.6 26.6H40.7c-12 0-21.7-9.7-21.7-21.7 0-11 8.2-20.1 18.8-21.3z"
+          fill="url(#grad)"
+          opacity="0.8"
+        />
+        <path
+          d="M47 78c0-3.3 2.7-6 6-6h24c3.3 0 6 2.7 6 6s-2.7 6-6 6H53c-3.3 0-6-2.7-6-6z"
+          fill="#0e1117"
+          opacity="0.9"
+        />
+      </svg>
+      <h1>You&rsquo;re offline</h1>
+      <p>
+        We can&rsquo;t reach ChatGPT right now. Your recent chats and cached content are still available,
+        and we&rsquo;ll reconnect automatically once you&rsquo;re back online.
+      </p>
+      <div class="actions">
+        <button class="retry" type="button" onclick="window.location.reload()">Try again</button>
+        <a class="cached" href="/" rel="home">Go to cached home</a>
+      </div>
+      <footer>Tip: keep this tab open so your work stays safe.</footer>
+    </main>
+  </body>
+</html>
diff --git a/scripts/prepare-web.js b/scripts/prepare-web.js
new file mode 100755
index 0000000..c6100da
--- /dev/null
+++ b/scripts/prepare-web.js
@@ -0,0 +1,217 @@
+#!/usr/bin/env node
+/* eslint-disable no-console */
+const fs = require('fs');
+const path = require('path');
+const crypto = require('crypto');
+
+async function main() {
+  const projectRoot = path.resolve(__dirname, '..');
+  const buildRoot = await resolveBuildDirectory(projectRoot);
+  if (!buildRoot) {
+    console.warn('[prepare-web] No hosted web build directory found. Skipping service worker preparation.');
+    return;
+  }
+
+  const offlineFileName = 'offline.html';
+  await ensureOfflineFallback(projectRoot, buildRoot, offlineFileName);
+
+  const precacheEntries = await collectPrecacheEntries(buildRoot);
+  if (!precacheEntries.includes(offlineFileName) && (await fileExists(path.join(buildRoot, offlineFileName)))) {
+    precacheEntries.push(offlineFileName);
+  }
+
+  precacheEntries.sort((a, b) => a.localeCompare(b));
+
+  const cacheVersion = await createCacheVersion(buildRoot, precacheEntries);
+  const swTemplatePath = path.join(projectRoot, 'sw.js');
+  if (!(await fileExists(swTemplatePath))) {
+    throw new Error(`[prepare-web] Service worker template not found at ${swTemplatePath}`);
+  }
+  const swTemplate = await fs.promises.readFile(swTemplatePath, 'utf8');
+  const swOutput = injectManifest(swTemplate, precacheEntries, cacheVersion);
+
+  const swOutputPath = path.join(buildRoot, 'sw.js');
+  await fs.promises.writeFile(swOutputPath, swOutput);
+  console.log(`[prepare-web] Wrote service worker with ${precacheEntries.length} precached assets (cache ${cacheVersion}).`);
+
+  await ensureSwRegistration(buildRoot, cacheVersion);
+}
+
+async function resolveBuildDirectory(projectRoot) {
+  const candidatePaths = [
+    'dist/hosted',
+    'dist/web',
+    'dist',
+    'web-build/hosted',
+    'web-build',
+    'build/web',
+    'build',
+  ].map((relativePath) => path.join(projectRoot, relativePath));
+
+  for (const directory of candidatePaths) {
+    if (await directoryExists(directory)) {
+      return directory;
+    }
+  }
+  return null;
+}
+
+async function ensureOfflineFallback(projectRoot, buildRoot, fileName) {
+  const sourcePath = path.join(projectRoot, fileName);
+  if (!(await fileExists(sourcePath))) {
+    console.warn(`[prepare-web] Offline fallback (${fileName}) not found in project root.`);
+    return;
+  }
+  const destinationPath = path.join(buildRoot, fileName);
+  await fs.promises.mkdir(path.dirname(destinationPath), { recursive: true });
+  await fs.promises.copyFile(sourcePath, destinationPath);
+}
+
+async function collectPrecacheEntries(buildRoot) {
+  const results = [];
+  await walkDirectory(buildRoot, async (absolutePath) => {
+    const relative = path.relative(buildRoot, absolutePath).split(path.sep).join('/');
+    if (!relative) {
+      return;
+    }
+    if (shouldSkip(relative)) {
+      return;
+    }
+    results.push(relative);
+  });
+  return Array.from(new Set(results));
+}
+
+function shouldSkip(relativePath) {
+  const normalized = relativePath.toLowerCase();
+  if (normalized === 'sw.js') {
+    return true;
+  }
+  if (normalized.endsWith('.map')) {
+    return true;
+  }
+  if (normalized === '.ds_store') {
+    return true;
+  }
+  return false;
+}
+
+async function walkDirectory(directory, onFile) {
+  const entries = await fs.promises.readdir(directory, { withFileTypes: true });
+  await Promise.all(
+    entries.map(async (entry) => {
+      const fullPath = path.join(directory, entry.name);
+      if (entry.isDirectory()) {
+        if (shouldSkipDirectory(entry.name)) {
+          return;
+        }
+        await walkDirectory(fullPath, onFile);
+        return;
+      }
+      if (entry.isFile()) {
+        await onFile(fullPath);
+      }
+    })
+  );
+}
+
+function shouldSkipDirectory(name) {
+  if (name.startsWith('.')) {
+    return name !== '.well-known';
+  }
+  return false;
+}
+
+async function createCacheVersion(buildRoot, precacheEntries) {
+  const hash = crypto.createHash('sha256');
+  for (const relative of precacheEntries) {
+    const absolute = path.join(buildRoot, relative);
+    try {
+      const stats = await fs.promises.stat(absolute);
+      hash.update(relative);
+      hash.update(String(stats.size));
+      hash.update(String(Math.floor(stats.mtimeMs)));
+    } catch (error) {
+      console.warn(`[prepare-web] Unable to stat ${relative} for cache versioning:`, error.message);
+    }
+  }
+  return `v${hash.digest('hex').slice(0, 16)}`;
+}
+
+function injectManifest(template, entries, cacheVersion) {
+  const manifestJson = JSON.stringify(entries);
+  const manifestString = `'${manifestJson.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}'`;
+  const versionString = `'${cacheVersion.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}'`;
+
+  if (!template.includes("'__PRECACHE_MANIFEST__'")) {
+    throw new Error('[prepare-web] Service worker template is missing the precache manifest placeholder.');
+  }
+  if (!template.includes("'__CACHE_VERSION__'")) {
+    throw new Error('[prepare-web] Service worker template is missing the cache version placeholder.');
+  }
+
+  return template
+    .replace(/'__PRECACHE_MANIFEST__'/g, manifestString)
+    .replace(/'__CACHE_VERSION__'/g, versionString);
+}
+
+async function ensureSwRegistration(buildRoot, cacheVersion) {
+  const htmlEntryCandidates = ['index.html', '200.html'];
+  const registrationSnippetId = 'sw-register';
+  const registrationSnippet =
+    `<script id="${registrationSnippetId}">\n` +
+    "  if ('serviceWorker' in navigator) {\n" +
+    "    window.addEventListener('load', () => {\n" +
+    "      const swUrl = new URL('sw.js', window.location.href);\n" +
+    `      swUrl.searchParams.set('v', '${cacheVersion}');\n` +
+    "      navigator.serviceWorker.register(swUrl.toString()).catch((error) => {\n" +
+    "        console.error('[sw] Registration failed', error);\n" +
+    "      });\n" +
+    "    });\n" +
+    "  }\n" +
+    "</script>";
+
+  for (const candidate of htmlEntryCandidates) {
+    const htmlPath = path.join(buildRoot, candidate);
+    if (!(await fileExists(htmlPath))) {
+      continue;
+    }
+    let html = await fs.promises.readFile(htmlPath, 'utf8');
+    if (html.includes('navigator.serviceWorker')) {
+      continue;
+    }
+    if (html.includes(`<script id="${registrationSnippetId}">`)) {
+      continue;
+    }
+    if (html.includes('</body>')) {
+      html = html.replace('</body>', `${registrationSnippet}\n</body>`);
+    } else {
+      html += `\n${registrationSnippet}\n`;
+    }
+    await fs.promises.writeFile(htmlPath, html);
+    console.log(`[prepare-web] Injected service worker registration snippet into ${candidate}.`);
+  }
+}
+
+async function fileExists(filePath) {
+  try {
+    await fs.promises.access(filePath, fs.constants.F_OK);
+    return true;
+  } catch (error) {
+    return false;
+  }
+}
+
+async function directoryExists(directoryPath) {
+  try {
+    const stats = await fs.promises.stat(directoryPath);
+    return stats.isDirectory();
+  } catch (error) {
+    return false;
+  }
+}
+
+main().catch((error) => {
+  console.error('[prepare-web] Failed:', error);
+  process.exit(1);
+});
diff --git a/sw.js b/sw.js
new file mode 100644
index 0000000..a1c4e43
--- /dev/null
+++ b/sw.js
@@ -0,0 +1,126 @@
+/* eslint-disable no-restricted-globals */
+const CACHE_PREFIX = 'chatgpt-web';
+const CACHE_VERSION_PLACEHOLDER = '__CACHE_VERSION__';
+const CACHE_VERSION = CACHE_VERSION_PLACEHOLDER === '__CACHE_VERSION__' ? 'dev' : CACHE_VERSION_PLACEHOLDER;
+const CACHE_NAME = `${CACHE_PREFIX}-${CACHE_VERSION}`;
+const OFFLINE_URL = 'offline.html';
+const PRECACHE_MANIFEST_PLACEHOLDER = '__PRECACHE_MANIFEST__';
+const PRECACHE_URLS = (() => {
+  try {
+    const parsed = JSON.parse(PRECACHE_MANIFEST_PLACEHOLDER);
+    if (Array.isArray(parsed) && parsed.length > 0) {
+      return parsed;
+    }
+  } catch (error) {
+    console.warn('[sw] Falling back to default precache manifest:', error);
+  }
+  return [OFFLINE_URL];
+})();
+
+const RUNTIME_CACHEABLE_REQUEST = ({ request }) => {
+  if (request.method !== 'GET') {
+    return false;
+  }
+  const url = new URL(request.url);
+  if (url.origin !== self.location.origin) {
+    return false;
+  }
+  if (url.pathname === '/sw.js') {
+    return false;
+  }
+  return true;
+};
+
+self.addEventListener('install', (event) => {
+  self.skipWaiting();
+  event.waitUntil(
+    (async () => {
+      const cache = await caches.open(CACHE_NAME);
+      const urlsToCache = Array.from(new Set([...PRECACHE_URLS, OFFLINE_URL]));
+      await cache.addAll(urlsToCache);
+    })()
+  );
+});
+
+self.addEventListener('activate', (event) => {
+  event.waitUntil(
+    (async () => {
+      const keys = await caches.keys();
+      const deletions = keys
+        .filter((cacheKey) => cacheKey.startsWith(`${CACHE_PREFIX}-`) && cacheKey !== CACHE_NAME)
+        .map((cacheKey) => caches.delete(cacheKey));
+      await Promise.all(deletions);
+      await self.clients.claim();
+    })()
+  );
+});
+
+self.addEventListener('fetch', (event) => {
+  const { request } = event;
+  if (request.method !== 'GET') {
+    return;
+  }
+  const url = new URL(request.url);
+  if (request.mode === 'navigate') {
+    event.respondWith(handleNavigationRequest(request));
+    return;
+  }
+  if (url.origin !== self.location.origin) {
+    return;
+  }
+  event.respondWith(handleAssetRequest(request));
+});
+
+async function handleNavigationRequest(request) {
+  try {
+    const networkResponse = await fetch(request);
+    if (networkResponse && networkResponse.ok) {
+      const cache = await caches.open(CACHE_NAME);
+      cache.put(request, networkResponse.clone()).catch((error) => {
+        console.warn('[sw] Unable to update navigation cache', error);
+      });
+    }
+    return networkResponse;
+  } catch (error) {
+    const cached = await caches.match(request);
+    if (cached) {
+      return cached;
+    }
+    const offlineResponse = await caches.match(OFFLINE_URL);
+    if (offlineResponse) {
+      return offlineResponse;
+    }
+    return new Response('You appear to be offline.', {
+      status: 503,
+      headers: { 'Content-Type': 'text/plain' },
+    });
+  }
+}
+
+async function handleAssetRequest(request) {
+  const cache = await caches.open(CACHE_NAME);
+  const cached = await cache.match(request);
+  if (cached) {
+    return cached;
+  }
+  if (!RUNTIME_CACHEABLE_REQUEST({ request })) {
+    return fetch(request);
+  }
+  try {
+    const networkResponse = await fetch(request);
+    if (networkResponse && networkResponse.ok && networkResponse.type !== 'opaque') {
+      cache.put(request, networkResponse.clone()).catch((error) => {
+        console.warn('[sw] Failed to cache response for', request.url, error);
+      });
+    }
+    return networkResponse;
+  } catch (error) {
+    if (request.destination === 'document') {
+      const offlineResponse = await caches.match(OFFLINE_URL);
+      if (offlineResponse) {
+        return offlineResponse;
+      }
+    }
+    throw error;
+  }
+}
-- 
2.43.0

